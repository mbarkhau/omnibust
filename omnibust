#!/usr/bin/env python
"""OmniBust cachebusting Script

Scans your project files for static resource references and updates their
cachebust parameters if they have any. The parameters are based on file
modification time and content hash.

Examples:

    url(/static/img/logo.png?_cb_=1234567);
    <img src="/static/img/logo.png?_cb_=1234567)">
    <link href="/static/css/style.css?_cb_=1234567" type="text/css">

Or filename based cachebusting (requires url rewriting by your http server):

    url(/static/img/logo_cb_1234567.png);
    <img src="/static/img/logo_cb_1234567.png)">
    <link href="/static/css/style_cb_1234567.css" type="text/css">

These references are matched up with static files and the values of their
_cb_ parameters is replaced with a hash of the contents of the referenced
file.

Usage:
    omnibust --init
    omnibust [--cfg=<omnibust.cfg>] [--view-scan]
    omnibust [--cfg=<omnibust.cfg>] [--no-act] [--no-cascade] [--force]
                [--filename] [--querystring]

Options:
    -h --help           Display this message
    -v --verbose        Verbose output
    -q --quiet          No output

    --view-scan         View scanned directories (to find ones which may be
                            excluded and speed up the scanning process)
    --cfg=<cfg_path>    Path to configuration file
                            [default: cachebust.init]
    --no-act            Only show (don't apply) busted references.
                            Warning: Will not find cascading changes.
    --no-cascade        Don't resolve cascading changes.
                            Cascades happen for example, when an html file has
                            a reference to a css file which in turn has a
                            reference to an image file. If the image is
                            modified, the reference in the css file will be
                            busted, which in turn will cause the reference in
                            the html file to be busted.
    -f --force          Update cachebust parameters even if the modification
                            time of the file is the same as indicated by the
                            current cachebust parameter.
    --filename          Rewrites all references so the filename contains a
                            cachebust parameter rather than the querystring.
    --querystring       Rewrites all references to use a _cb_ parameter as
                            part of the querystring.
"""
from __future__ import print_function

import os
import sys
import re
import json
import struct
import codecs
from zlib import crc32
from base64 import b32encode
from fnmatch import fnmatch

PY2 = sys.version < '3'

unicode = unicode if PY2 else str


# util functions

def filepaths(rootdir, dir_exclude=None, ext_filter=None, view_scan=False):
    if isinstance(ext_filter, (unicode, bytes)):
        _filter = lambda p: p.endswith(ext_filter)
    elif isinstance(ext_filter, tuple):
        _filter = lambda p: os.path.splitext(p)[1] in ext_filter
    else:
        _filter = ext_filter

    for root, subfolders, files in os.walk(rootdir):
        root = os.path.abspath(root)
        if dir_exclude and dir_exclude(root):
            continue

        if view_scan:
            print(root)

        for filename in files:
            path = os.path.join(root, filename)
            if not _filter or _filter(path):
                yield path


def mk_globfilter(globs):
    def globfilter(path):
        for glob in globs:
            if fnmatch(path, glob):
                return True
        return False
    return globfilter


def expand_reference(ref, expansions):
    allrefs = set([ref])
    for search, replacements in expansions.items():
        if search in ref:
            allrefs.update((ref.replace(search, r) for r in replacements))
                
    return allrefs


def contenthash(content):
    return b32encode(struct.pack("<i", crc32(content)))[:-1].lower()


def filehash(filepath):
    with open(filepath, 'rb') as f:
        return contenthash(f.read())


def filestat(filepath):
    t = os.stat(filepath).st_mtime
    return b32encode(struct.pack("<i", t))[:-1].lower()


def hash_files(filepaths, fn):
    if len(filepaths) == 1:
        fhash = contenthash(fn(filepaths[0]))
    else:
        fhash = contenthash("".join((fn(path) for path in filepaths)))

    return fhash


def _find_paths(rootdir, basedirs, exclude_globs, filter_globs, view_scan):
    exclude_paths = mk_globfilter(exclude_globs)
    filter_paths = mk_globfilter(filter_globs)

    rootdir = os.path.abspath(rootdir)

    for basedir in basedirs:
        basedir = os.path.join(rootdir, basedir)

        if not os.path.exists(basedir):
            continue

        for path in filepaths(basedir, exclude_paths, filter_paths, view_scan):
            yield path


def find_content_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['search_dirs'],
                       cfg['ignore_dirs'], cfg['search_files'],
                       '--view-scan' in args)


def find_static_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['static_dirs'],
                       cfg['ignore_dirs'], cfg['static_files'],
                       '--view-scan' in args)


def resolve_filepath(ref, static_paths):
    longest_spath = ""
    longest_path = None

    subpaths = ref.split("/")
    for path in static_paths:
        if not path.endswith(subpaths[-1]):
            continue

        for i in xrange(1, len(subpaths) + 1):
            spath = os.path.sep.join(subpaths[-i:])
            if spath in path:
                if len(spath) > len(longest_spath):
                    longest_spath = spath
                    longest_path = path
            else:
                break
    
    return longest_path


def resolve_reference(cfg, ref, static_paths):
    ref = ref.replace("/", os.sep)

    for ref in expand_reference(ref, cfg['multibust']):
        filepath = resolve_filepath(ref, static_paths)
        if filepath:
            yield filepath


FN_REF = 1
FN_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']|src=[\"\'])?"
    "(?P<path>"
    "(?P<prefix>[^\"\'\s]+?)"
    "_cb_(?P<bust>[a-zA-Z0-9]{0,16})"
    "(?P<ext>\.\w+?))"
)

QS_REF = 2
QS_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']|src=[\"\'])?"
    "(?P<path>"
    "(?P<ref>[^\"\'\s]+?)"
    "\?(.+?&)?_cb_"
    "(=(?P<bust>[a-zA-Z0-9]{0,16}))?)"
)


def find_references(content):
    if "_cb_" not in content:
        return

    for lineno, line in enumerate(content.splitlines()):
        lineno += 1
        if "_cb_" not in line:
            continue

        for match in FN_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('prefix') + match.group('ext')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, FN_REF

        for match in QS_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('ref')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, QS_REF


def update_ref(content, full_ref, ref, old_bust, new_bust,
               old_ref_type, new_ref_type):
    if old_ref_type == new_ref_type:
        new_full_ref = full_ref.replace(old_bust, new_bust)
    else:
        # TODO: extend regular expression to capture all query parameters
        #       parse query params from full_ref
        #       reconstruct new query params
        raise NotImplemented("changing ref types")
    return content.replace(full_ref, new_full_ref)


def update_references(cfg, args, filepath, static_paths):
    to_fn = '--filename' in args
    to_qs = '--querystring' in args

    arg_verbose = '-v' in args or '--verbose' in args
    arg_quiet = '-q' in args or '--quiet' in args
    arg_force = '-f' in args or '--force' in args
    arg_noact = '-n' in args or '--no-act' in args

    tgt_ref_type = None
    if to_fn and not to_qs:
        tgt_ref_type = FN_REF
    if to_qs and not to_fn:
        tgt_ref_type = QS_REF

    with codecs.open(filepath, 'r', encoding=cfg['file_encoding']) as f:
        orig_content = f.read()

    content = orig_content

    references = find_references(orig_content)
    for lineno, full_ref, fn_ref, old_bust, old_ref_type in references:
        if arg_verbose:
            fmtstr = '{1}, line {2:<4}: {0}'
            print(fmtstr.format(full_ref, filepath, lineno))

        new_ref_type = tgt_ref_type or old_ref_type
        paths = tuple(resolve_reference(cfg, fn_ref, static_paths))

        if len(paths) == 0:
            if not arg_quiet:
                print("missing! : " + full_ref)
            continue

        needs_change = old_ref_type != new_ref_type or arg_force

        new_stat = hash_files(paths, filestat)[:5]

        if not needs_change and old_bust.startswith(new_stat):
            if arg_verbose:
                print("unchanged: " + full_ref)
            continue

        new_hash = hash_files(paths, filehash)[:5]

        if not needs_change and old_bust.endswith(new_hash):
            continue

        new_bust = new_stat + new_hash

        if not arg_quiet:
            print("busted   : {0} -> {1}".format(full_ref, new_bust))

        content = update_ref(content, full_ref, fn_ref, old_bust, new_bust,
                             old_ref_type, new_ref_type)

    if arg_noact:
        return

    if content == orig_content:
        return

    if arg_verbose:
        print("rewriting:", filepath)

    with codecs.open(filepath, 'w', encoding=cfg['file_encoding']) as f:
        f.write(content)


def omnibust(cfg, args):
    content_paths = find_content_paths(cfg, args)
    static_paths = list(find_static_paths(cfg, args))

    for filepath in content_paths:
        update_references(cfg, args, filepath, static_paths)


COMMENT_RE = re.compile("//.*")


DEFAULT_CFG = r"""
{
    "file_encoding": "utf-8",

    "root_dir": ".",
    "search_dirs": ["."],             // relative to base_dir
    // search for cachebust references is restricted to these filetypes
    "search_files": ["*.html", "*.jade", "*.erb", "*.haml",
                     "*.css", "*.less", "*.sass", "*.scss",
                     "*.js", "*.coffee", "*.py", "*.rb", "*.php"],

    // search for bustable files is restricted to these filetypes
    "static_dirs": ["static", "media", "assets"],
    "static_files": ["*.ico", "*.png", "*.gif", "*.jpg", "*.jpeg",
                     "*.js", "*.css"],

    "ignore_dirs": ["*/lib/*", "*/lib64/*", "*.git/*", "*.hg/*", "*.svn/*"],

    // Cachebust references which contain a multibust marker are expanded
    // using each of the replacements. The cachebust hash will be unique
    // for the combination of all static resources. Example:
    //
    //     <img src="/static/i18n_img_{{ lang }}.png?_ocb_=1234567">
    //
    // If either of /static/i18n_img_en.png or /static/i18n_img_de.png are
    // changed, then the cachebust varible will be refreshed.
    "multibust": {
        "{{ lang }}": ["en", "de"]     // marker: replacements
    }
}
"""


def main(args=sys.argv):
    if "-h" in args or "--help" in args:
        print(__doc__)
        return

    print(args)
    cfg = json.loads(COMMENT_RE.sub("", DEFAULT_CFG))
    omnibust(cfg, args)


if __name__ == '__main__':
    sys.exit(main())
