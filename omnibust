#!/usr/bin/env python
"""OmniBust - A cachebusting script

Omnibust scans your project files for static resources, such as js, css, png
files, and urls which reference these resources in your sourcecode (html, js,
css, py, rb, etc.). It will rewrite any such urls so they have a unique
cachebust parameter, which is based on the modification time and a checksum of
the contents of the static resource files.

Omnibust defaults to query parameter `_cb_=0123abcd` based cachbusting, but it
can also rewrite the filenames in urls to the form  `app_cb_0123abcd.js`. See
[Filename Based Cachbusting] for more info on why you might want to use this.

Usage:
    omnibust init [<rootdir>] [--cfg=<cfg_path>]
    omnibust rewrite [<rootdir>] [--cfg=<cfg_path>]
                [--cascade] [--no-act] [--force]
                [--filename] [--querystring]
    omnibust update [<rootdir>] [--cfg=<cfg_path>]
                [--cascade] [--no-act] [--force]
    omnibust scan [<rootdir>] [--cfg=<cfg_path>]

Options:
    -h --help           Display this message
    -v --verbose        Verbose output
    -q --quiet          No output
    --version           Display version number

    init                Scan working directory for static files and references
                            to them, and write an initial omnibust.cfg
    scan                View scanned directories (to find ones which may be
                            excluded and speed up the scanning process)
    --cfg=<cfg_path>    Path to configuration file
                            [default: cachebust.init]
    -n --no-act         Don't write to files, only display changes that would
                            have been made.
    -c --cascade        Resolve cascading changes to urls.
                            Cascades happen for example, when an html file has
                            a reference to a css file which in turn has a
                            reference to an image file. If the image is
                            modified, the reference in the css file will be
                            busted, which in turn will cause the css reference
                            in the html file to be busted.
    -f --force          Update cachebust parameters even if the modification
                            time of the file is the same as recorded in the
                            current cachebust parameter.
    --filename          Rewrites all references so the filename contains a
                            cachebust parameter rather than the querystring.
    --querystring       Rewrites all references to use a _cb_ parameter as
                            part of the querystring.
"""
from __future__ import print_function

import os
import sys
import re
import json
import struct
import codecs

import zlib
import hashlib
import base64
import fnmatch

PY2 = sys.version < '3'

unicode = unicode if PY2 else str


# util functions

def glob_matcher(globs):
    def _matcher(glob):
        return lambda path: fnmatch.fnmatch(path, glob)

    if isinstance(globs, (tuple, list)):
        matchers = map(_matcher, globs)
        return lambda p: any((m(p) for m in matchers))
    if isinstance(globs, (unicode, bytes)):
        return _matcher(globs)

    return globs


def iter_filepaths(rootdir, _filter=None, _exclude=None, _print=False):
    _filter = glob_matcher(_filter)
    _exclude = glob_matcher(_exclude)

    for root, subfolders, files in os.walk(rootdir):
        if _exclude and _exclude(root):
            continue

        if _print:
            print(root)

        for filename in files:
            path = os.path.join(root, filename)
            if _exclude and _exclude(root):
                continue

            if not _filter or _filter(path):
                yield path


def mk_globfilter(globs):
    def globfilter(path):
        for glob in globs:
            if fnmatch.fnmatch(path, glob):
                return True
        return False
    return globfilter


def expand_reference(ref, expansions):
    allrefs = set([ref])
    for search, replacements in expansions.items():
        if search in ref:
            allrefs.update((ref.replace(search, r) for r in replacements))

    return allrefs


def b32enc(val):
    if isinstance(val, int):
        val = struct.pack("<i", val)
    return base64.b32encode(val)[:-1].lower()


def contenthash(content, hashfunc='crc32'):
    if hashfunc in hashlib.algorithms:
        hashval = hashlib.new(hashfunc, content).digest()
    else:
        hashval = zlib.crc32(content)

    return b32enc(hashval)


def filehash(filepath, hashfunc):
    with open(filepath, 'rb') as f:
        return contenthash(f.read(), hashfunc)


def filestat(filepath):
    mtime = os.stat(filepath).st_mtime
    return b32enc(mtime)


def hash_files(filepaths, fn):
    if len(filepaths) == 1:
        fhash = contenthash(fn(filepaths[0]))
    else:
        fhash = contenthash("".join((fn(path) for path in filepaths)))

    return fhash


def _find_paths(rootdir, basedirs, filter_globs, exclude_globs, print_scan):
    filter_paths = mk_globfilter(filter_globs)
    exclude_paths = mk_globfilter(exclude_globs)

    for basedir in basedirs:
        basedir = os.path.join(rootdir, basedir)

        if not os.path.exists(basedir):
            continue

        for path in iter_filepaths(basedir, filter_paths, exclude_paths,
                                   print_scan):
            yield path


def find_content_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['ignore_dirs'], cfg['search_dirs'],
                       cfg['search_files'], '--view-scan' in args)


def find_static_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['static_dirs'],
                       cfg['ignore_dirs'], cfg['static_files'],
                       '--view-scan' in args)


def resolve_filepath(ref, static_paths):
    longest_spath = ""
    longest_path = None

    subpaths = ref.split("/")
    for path in static_paths:
        if not path.endswith(subpaths[-1]):
            continue

        for i in xrange(1, len(subpaths) + 1):
            spath = os.path.sep.join(subpaths[-i:])
            if spath in path:
                if len(spath) > len(longest_spath):
                    longest_spath = spath
                    longest_path = path
            else:
                break

    return longest_path


def resolve_reference(cfg, ref, static_paths):
    ref = ref.replace("/", os.sep)

    for ref in expand_reference(ref, cfg['multibust']):
        filepath = resolve_filepath(ref, static_paths)
        if filepath:
            yield filepath


REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']?|src=[\"\']?)"
    "(?P<path>[^\"\'\s]+)"
)

FN_REF = 1
FN_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']?|src=[\"\']?)?"
    "(?P<path>"
    "(?P<prefix>[^\"\'\s]+?)"
    "_cb_(?P<bust>[a-zA-Z0-9]{0,16})"
    "(?P<ext>\.\w+?))"
)

QS_REF = 2
QS_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']?|src=[\"\']?)?"
    "(?P<path>"
    "(?P<ref>[^\"\'\s]+?)"
    "\?(.+?&)?_cb_"
    "(=(?P<bust>[a-zA-Z0-9]{0,16}))?)"
)


def find_references(content):
    if "_cb_" not in content:
        return

    for lineno, line in enumerate(content.splitlines()):
        lineno += 1
        if "_cb_" not in line:
            continue

        for match in FN_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('prefix') + match.group('ext')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, FN_REF

        for match in QS_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('ref')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, QS_REF


def update_ref(content, full_ref, ref, old_bust, new_bust,
               old_ref_type, new_ref_type):
    if old_ref_type == new_ref_type:
        new_full_ref = full_ref.replace(old_bust, new_bust)
    else:
        # TODO: extend regular expression to capture all query parameters
        #       parse query params from full_ref
        #       reconstruct new query params
        raise NotImplemented("changing ref types")
    return content.replace(full_ref, new_full_ref)


def update_references(cfg, args, filepath, static_paths):
    arg_verbose = '-v' in args or '--verbose' in args
    arg_quiet = '-q' in args or '--quiet' in args
    arg_force = '-f' in args or '--force' in args

    force_fn = '--filename' in args
    force_qs = '--querystring' in args

    tgt_ref_type = None
    if force_fn and not force_qs:
        tgt_ref_type = FN_REF
    if force_qs and not force_fn:
        tgt_ref_type = QS_REF

    hash_fun = cfg['hash_function']
    hash_length = int(cfg['hash_length'])
    stat_len = min(6, hash_length // 2)
    hash_len = hash_length - stat_len

    file_enc = cfg['file_encoding']

    with codecs.open(filepath, 'r', encoding=file_enc) as f:
        orig_content = f.read()

    content = orig_content

    references = find_references(orig_content)
    for lineno, full_ref, fn_ref, old_bust, old_ref_type in references:
        if arg_verbose:
            fmtstr = '{1}, line {2:<4}: {0}'
            print(fmtstr.format(full_ref, filepath, lineno))

        new_ref_type = tgt_ref_type or old_ref_type
        paths = tuple(resolve_reference(cfg, fn_ref, static_paths))

        if len(paths) == 0:
            if not arg_quiet:
                print("missing! : " + full_ref)
            continue

        needs_change = old_ref_type != new_ref_type or arg_force

        new_stat = hash_files(paths, filestat)[:stat_len]

        if not needs_change and old_bust.startswith(new_stat):
            if arg_verbose:
                print("unchanged: " + full_ref)
            continue

        new_hash = hash_files(paths, filehash, hash_fun)[:hash_len]

        if not needs_change and old_bust.endswith(new_hash):
            continue

        new_bust = new_stat + new_hash

        if not arg_quiet:
            print("busted   : {0} -> {1}".format(full_ref, new_bust))

        content = update_ref(content, full_ref, fn_ref, old_bust, new_bust,
                             old_ref_type, new_ref_type)

    if content == orig_content:
        return

    if arg_verbose:
        print("rewriting:", filepath)

    with codecs.open(filepath, 'w', encoding=file_enc) as f:
        f.write(content)


def init_cmd(cfg, args):
    rootdir = parse_rootdir(args)
    print("init", args)
    print(rootdir)
    for p in iter_filepaths(rootdir):
        print(p)


def scan_cmd(cfg, args):
    rootdir = parse_rootdir(args)
    print("scan", args, rootdir)
    pass


def rewrite_cmd(cfg, args):
    rootdir = parse_rootdir(args)
    print("rewrite", args, rootdir)


def update_cmd(cfg, args):
    content_paths = find_content_paths(cfg, args)
    static_paths = list(find_static_paths(cfg, args))

    for filepath in content_paths:
        update_references(cfg, args, filepath, static_paths)


# Option/Configuration parsing

INIT_CFG = r"""

    // Cachebust references which contain a multibust marker are expanded
    // using each of the replacements. The cachebust hash will be unique
    // for the combination of all static resources. Example:
    //
    //     <img src="/static/i18n_img_{{ lang }}.png?_cb_=1234567">
    //
    // If either of /static/i18n_img_en.png or /static/i18n_img_de.png are
    // changed, then the cachebust varible will be refreshed.
    // "multibust": {
    //    "{{ lang }}": ["en", "de"]  // marker: replacements
    // },

    // "file_encoding": "utf-8",

    // "hash_function": "crc32",      // sha1, sha256, sha512
    // "hash_length": 10,
"""


DEFAULT_CFG = r"""
{
    "search_dirs": ["."],             // relative to <rootdir>
    // search for cachebust references is restricted to these filetypes
    "search_files": ["*.html", "*.jade", "*.erb", "*.haml",
                     "*.css", "*.less", "*.sass", "*.scss",
                     "*.js", "*.coffee", "*.py", "*.rb", "*.php"],

    // search for bustable files is restricted to these filetypes
    "static_dirs": ["static", "media", "assets"],
    "static_files": ["*.ico", "*.png", "*.gif", "*.jpg", "*.jpeg",
                     "*.js", "*.css"],

    "ignore_dirs": ["*/lib/*", "*/lib64/*", "*.git/*", "*.hg/*", "*.svn/*"],

    "multibust": {},

    "file_encoding": "utf-8",
    "hash_function": "crc32"
    "hash_length": 12
}
"""


def clean_cfg(data):
    return re.sub("//.*", "", data)


def parse_rootdir(args):
    if len(args) > 1:
        path = args[1]
        if os.path.exists(path):
            return path
    return "."


def has_flag(args, flag):
    return flag in args or flag[1:3] in args


CMD_MAP = {
    'init': init_cmd,
    'scan': scan_cmd,
    'rewrite': rewrite_cmd,
    'update': update_cmd,
}


def read_cfg(args):
    cfg = json.loads(clean_cfg(DEFAULT_CFG))

    argiter = iter(args)
    fn = None
    for arg in argiter:
        if arg.startswith('--cfg'):
            cfg_arg = arg.split("=")
            if len(cfg_arg) == 2:
                fn = cfg_arg[1]
            else:
                fn = next(argiter)
            break

    if fn and not os.path.exists(fn):
        print("omnibust: %s: No such file or directory" % fn)
        return

    if fn:
        try:
            with codecs.open(fn, 'r', encoding='utf-8') as f:
                cfg.update(json.loads(clean_cfg(f.read())))
        except (ValueError, IOError) as e:
            print("omnibust: Error parsing '%s'" % fn, e)
            return

    if 'file_encoding' not in cfg:
        cfg['file_encoding'] = sys.getfilesystemencoding()

    return cfg


def main(args=sys.argv[1:]):
    if not args:
        print(__doc__.split("Options:")[0].strip())
        return

    if "-h" in args or "--help" in args or not args:
        print(__doc__)
        return

    cmd = args[0] if len(args) > 0 else None
    if cmd and cmd not in CMD_MAP:
        print("omnibust: Invalid command: '%s' available: (%s)" % (
            cmd, "|".join(CMD_MAP))
        )
        return

    cfg = read_cfg(args)
    if cfg is None:
        return 1

    return CMD_MAP[cmd](cfg, args)


if __name__ == '__main__':
    sys.exit(main())
