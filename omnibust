#!/usr/bin/env python
"""OmniBust - A cachebusting script

Omnibust scans your project files for static resources, such as js, css, png
files, and urls which reference these resources in your sourcecode (html, js,
css, py, rb, etc.). It will rewrite any such urls so they have a unique
cachebust parameter, which is based on the modification time and contents of
the static resource files.

Omnibust defaults to query parameter `_cb_=0123abcd` based cachbusting, but it
can also rewrite the filenames in urls to the form  `app_cb_0123abcd.js`. See
[Filename Based Cachbusting] for more info on why you might want to use this.

Usage:
    omnibust init [--cfg=<cfg_path>]
    omnibust scan [--cfg=<cfg_path>]
    omnibust update [--cfg=<cfg_path>] [--no-cascade] [--force]
    omnibust rewrite [--cfg=<cfg_path>] [--no-cascade] [--force]
                [--filename] [--querystring]

Options:
    -h --help           Display this message
    -v --verbose        Verbose output
    -q --quiet          No output
    --version           Display version number

    init                Scan working directory for static files and references
                            to them, and write an initial omnibust.cfg
    scan                View scanned directories (to find ones which may be
                            excluded and speed up the scanning process)
    --cfg=<cfg_path>    Path to configuration file
                            [default: cachebust.init]
    --no-cascade        Don't resolve cascading changes.
                            Cascades happen for example, when an html file has
                            a reference to a css file which in turn has a
                            reference to an image file. If the image is
                            modified, the reference in the css file will be
                            busted, which in turn will cause the reference in
                            the html file to be busted.
    -f --force          Update cachebust parameters even if the modification
                            time of the file is the same as indicated by the
                            current cachebust parameter.
    --filename          Rewrites all references so the filename contains a
                            cachebust parameter rather than the querystring.
    --querystring       Rewrites all references to use a _cb_ parameter as
                            part of the querystring.
"""
from __future__ import print_function

import os
import sys
import re
import json
import struct
import codecs
from zlib import crc32
from base64 import b32encode
from fnmatch import fnmatch

PY2 = sys.version < '3'

unicode = unicode if PY2 else str


# util functions

def filepaths(rootdir, dir_exclude=None, ext_filter=None, view_scan=False):
    if isinstance(ext_filter, (unicode, bytes)):
        _filter = lambda p: p.endswith(ext_filter)
    elif isinstance(ext_filter, tuple):
        _filter = lambda p: os.path.splitext(p)[1] in ext_filter
    else:
        _filter = ext_filter

    for root, subfolders, files in os.walk(rootdir):
        root = os.path.abspath(root)
        if dir_exclude and dir_exclude(root):
            continue

        if view_scan:
            print(root)

        for filename in files:
            path = os.path.join(root, filename)
            if not _filter or _filter(path):
                yield path


def mk_globfilter(globs):
    def globfilter(path):
        for glob in globs:
            if fnmatch(path, glob):
                return True
        return False
    return globfilter


def expand_reference(ref, expansions):
    allrefs = set([ref])
    for search, replacements in expansions.items():
        if search in ref:
            allrefs.update((ref.replace(search, r) for r in replacements))
                
    return allrefs


def contenthash(content):
    return b32encode(struct.pack("<i", crc32(content)))[:-1].lower()


def filehash(filepath):
    with open(filepath, 'rb') as f:
        return contenthash(f.read())


def filestat(filepath):
    t = os.stat(filepath).st_mtime
    return b32encode(struct.pack("<i", t))[:-1].lower()


def hash_files(filepaths, fn):
    if len(filepaths) == 1:
        fhash = contenthash(fn(filepaths[0]))
    else:
        fhash = contenthash("".join((fn(path) for path in filepaths)))

    return fhash


def _find_paths(rootdir, basedirs, exclude_globs, filter_globs, view_scan):
    exclude_paths = mk_globfilter(exclude_globs)
    filter_paths = mk_globfilter(filter_globs)

    rootdir = os.path.abspath(rootdir)

    for basedir in basedirs:
        basedir = os.path.join(rootdir, basedir)

        if not os.path.exists(basedir):
            continue

        for path in filepaths(basedir, exclude_paths, filter_paths, view_scan):
            yield path


def find_content_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['search_dirs'],
                       cfg['ignore_dirs'], cfg['search_files'],
                       '--view-scan' in args)


def find_static_paths(cfg, args):
    return _find_paths(cfg['root_dir'], cfg['static_dirs'],
                       cfg['ignore_dirs'], cfg['static_files'],
                       '--view-scan' in args)


def resolve_filepath(ref, static_paths):
    longest_spath = ""
    longest_path = None

    subpaths = ref.split("/")
    for path in static_paths:
        if not path.endswith(subpaths[-1]):
            continue

        for i in xrange(1, len(subpaths) + 1):
            spath = os.path.sep.join(subpaths[-i:])
            if spath in path:
                if len(spath) > len(longest_spath):
                    longest_spath = spath
                    longest_path = path
            else:
                break
    
    return longest_path


def resolve_reference(cfg, ref, static_paths):
    ref = ref.replace("/", os.sep)

    for ref in expand_reference(ref, cfg['multibust']):
        filepath = resolve_filepath(ref, static_paths)
        if filepath:
            yield filepath


FN_REF = 1
FN_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']|src=[\"\'])?"
    "(?P<path>"
    "(?P<prefix>[^\"\'\s]+?)"
    "_cb_(?P<bust>[a-zA-Z0-9]{0,16})"
    "(?P<ext>\.\w+?))"
)

QS_REF = 2
QS_REF_RE = re.compile(
    r"(url\([\"\']?|href=[\"\']|src=[\"\'])?"
    "(?P<path>"
    "(?P<ref>[^\"\'\s]+?)"
    "\?(.+?&)?_cb_"
    "(=(?P<bust>[a-zA-Z0-9]{0,16}))?)"
)


def find_references(content):
    if "_cb_" not in content:
        return

    for lineno, line in enumerate(content.splitlines()):
        lineno += 1
        if "_cb_" not in line:
            continue

        for match in FN_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('prefix') + match.group('ext')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, FN_REF

        for match in QS_REF_RE.finditer(line):
            full_ref = match.group('path')
            fn_ref = match.group('ref')
            old_bust = match.group('bust')
            yield lineno, full_ref, fn_ref, old_bust, QS_REF


def update_ref(content, full_ref, ref, old_bust, new_bust,
               old_ref_type, new_ref_type):
    if old_ref_type == new_ref_type:
        new_full_ref = full_ref.replace(old_bust, new_bust)
    else:
        # TODO: extend regular expression to capture all query parameters
        #       parse query params from full_ref
        #       reconstruct new query params
        raise NotImplemented("changing ref types")
    return content.replace(full_ref, new_full_ref)


def update_references(cfg, args, filepath, static_paths):
    to_fn = '--filename' in args
    to_qs = '--querystring' in args

    arg_verbose = '-v' in args or '--verbose' in args
    arg_quiet = '-q' in args or '--quiet' in args
    arg_force = '-f' in args or '--force' in args

    tgt_ref_type = None
    if to_fn and not to_qs:
        tgt_ref_type = FN_REF
    if to_qs and not to_fn:
        tgt_ref_type = QS_REF

    with codecs.open(filepath, 'r', encoding=cfg['file_encoding']) as f:
        orig_content = f.read()

    content = orig_content

    references = find_references(orig_content)
    for lineno, full_ref, fn_ref, old_bust, old_ref_type in references:
        if arg_verbose:
            fmtstr = '{1}, line {2:<4}: {0}'
            print(fmtstr.format(full_ref, filepath, lineno))

        new_ref_type = tgt_ref_type or old_ref_type
        paths = tuple(resolve_reference(cfg, fn_ref, static_paths))

        if len(paths) == 0:
            if not arg_quiet:
                print("missing! : " + full_ref)
            continue

        needs_change = old_ref_type != new_ref_type or arg_force

        new_stat = hash_files(paths, filestat)[:5]

        if not needs_change and old_bust.startswith(new_stat):
            if arg_verbose:
                print("unchanged: " + full_ref)
            continue

        new_hash = hash_files(paths, filehash)[:5]

        if not needs_change and old_bust.endswith(new_hash):
            continue

        new_bust = new_stat + new_hash

        if not arg_quiet:
            print("busted   : {0} -> {1}".format(full_ref, new_bust))

        content = update_ref(content, full_ref, fn_ref, old_bust, new_bust,
                             old_ref_type, new_ref_type)

    if arg_noact:
        return

    if content == orig_content:
        return

    if arg_verbose:
        print("rewriting:", filepath)

    with codecs.open(filepath, 'w', encoding=cfg['file_encoding']) as f:
        f.write(content)


def init_cmd(cfg, args):
    pass


def scan_cmd(cfg, args):
    pass


def rewrite_cmd(cfg, args):
    pass


def update_cmd(cfg, args):
    content_paths = find_content_paths(cfg, args)
    static_paths = list(find_static_paths(cfg, args))

    for filepath in content_paths:
        update_references(cfg, args, filepath, static_paths)


# Option/Configuration parsing


DEFAULT_CFG = r"""
{
    "file_encoding": "utf-8",

    "root_dir": ".",
    "search_dirs": ["."],             // relative to base_dir
    // search for cachebust references is restricted to these filetypes
    "search_files": ["*.html", "*.jade", "*.erb", "*.haml",
                     "*.css", "*.less", "*.sass", "*.scss",
                     "*.js", "*.coffee", "*.py", "*.rb", "*.php"],

    // search for bustable files is restricted to these filetypes
    "static_dirs": ["static", "media", "assets"],
    "static_files": ["*.ico", "*.png", "*.gif", "*.jpg", "*.jpeg",
                     "*.js", "*.css"],

    "ignore_dirs": ["*/lib/*", "*/lib64/*", "*.git/*", "*.hg/*", "*.svn/*"],

    // Cachebust references which contain a multibust marker are expanded
    // using each of the replacements. The cachebust hash will be unique
    // for the combination of all static resources. Example:
    //
    //     <img src="/static/i18n_img_{{ lang }}.png?_ocb_=1234567">
    //
    // If either of /static/i18n_img_en.png or /static/i18n_img_de.png are
    // changed, then the cachebust varible will be refreshed.
    "multibust": {
        "{{ lang }}": ["en", "de"]     // marker: replacements
    }
}
"""


def clean_cfg(data):
    return re.sub("//.*", "", data)


CMD_MAP = {
    'init': init_cmd,
    'scan': scan_cmd,
    'rewrite': rewrite_cmd,
    'update': update_cmd,
}


def read_cfg(args):
    cfg = json.loads(clean_cfg(DEFAULT_CFG))

    argiter = iter(args)
    fn = None
    for arg in argiter:
        if arg.startswith('--cfg'):
            cfg_arg = arg.split("=")
            if len(cfg_arg) == 2:
                fn = cfg_arg[1]
            else:
                fn = next(argiter)
            break

    if not fn:
        return cfg

    if not os.path.exists(fn):
        print("omnibust: %s: No such file or directory" % fn)
        return

    try:
        with codecs.open(fn, 'r', encoding='utf-8') as f:
            cfg.update(json.loads(clean_cfg(f.read())))
            return cfg
    except (ValueError, IOError) as e:
        print("omnibust: Error parsing '%s'" % fn, e)


def main(args=sys.argv[1:]):
    if not args:
        print(__doc__.split("Options:")[0].strip())
        return

    if "-h" in args or "--help" in args or not args:
        print(__doc__)
        return

    cmd = args[0] if len(args) > 0 else None
    if cmd and cmd not in CMD_MAP:
        print("omnibust: Invalid command: '%s' available: (%s)" % (
            cmd, "|".join(CMD_MAP))
        )
        return

    cfg = read_cfg(args)
    if cfg is None:
        return 1

    return CMD_MAP[cmd](cfg, args)


if __name__ == '__main__':
    sys.exit(main())
